#!/usr/bin/env python
import rospy
from rgb_led import *
import sys
import time
from std_msgs.msg import Float32, Int8, String
from rgb_led import RGB_LED
from duckietown_msgs.msg import BoolStamped


class LEDEmitterNode(object):
    def __init__(self):
        self.node_name = rospy.get_name()
        rospy.loginfo("[%s] Initializing..." % (self.node_name))

        self.led = RGB_LED()

        self.active = True

        # Initialize LEDs to be off
        self.pattern = [[0, 0, 0]]*5
        self.current_pattern_name = 'light_off'
        self.changePattern_(self.current_pattern_name)

        # Import protocol
        self.protocol = rospy.get_param("~LED_protocol")

        # Import parameters
        self.scale = rospy.get_param("~LED_scale")

        # If True, the LED turn on and off. Else, they are always on
        self.onOff = True

        if self.onOff:
            self.cycle = 1.0/self.protocol['signals']['CAR_SIGNAL_A']['frequency']
            self.is_on = False
            self.cycle_timer = rospy.Timer(rospy.Duration.from_sec(self.cycle/(2.0)), self.cycleTimer)

        # Publishers
        self.pub_state = rospy.Publisher("~current_led_state", String, queue_size=1)

        # Subscribers
        self.sub_pattern = rospy.Subscriber("~change_color_pattern", String, self.changePattern)
        self.sub_switch = rospy.Subscriber("~switch", BoolStamped, self.cbSwitch)

        # Scale intensity of the LEDs
        for _, c in self.protocol['colors'].items():
            for i in range(3):
                c[i] = c[i] * self.scale

        rospy.loginfo("[%s] Initialized." % (self.node_name))

    def cbSwitch(self, switch_msg):
        """Callback that turns on/off the node

            Reads the switch from the Finite State Machine and sets
            self.active accordingly.

            Args:
                switch_msg (BoolStamped): Switch for the node.
        """
        self.active = switch_msg.data

    def cycleTimer(self, event):
        """Switches the LEDs on/off

        If on oscillation mode (on/off) switches the LED according to a Timer
        dictated by the requested frequency. Otherwise only changes the color
        of the LEDs

        Args:
            event (TimerEvent): event generated by the timer.
        """

        # Do nothing if inactive
        if not self.active:
            return

        elif not self.onOff:
            # No oscillation
            for i in range(5):
                colors = [self.pattern[i][0],
                          self.pattern[i][1],
                          self.pattern[i][2]]
                self.led.setRGB(i, colors)
        else:
            # Oscillate
            if self.is_on:
                for i in range(5):
                    self.led.setRGB(i, [0, 0, 0])
                self.is_on = False

            else:
                for i in range(5):
                    colors = [self.pattern[i][0],
                              self.pattern[i][1],
                              self.pattern[i][2]]
                    self.led.setRGB(i, colors)
                self.is_on = True

    def changePattern(self, msg):
        self.changePattern_(msg.data)

    def changePattern_(self, pattern_name):
        """Change the current LED pattern.

        Checks if the requested pattern is different from the current one,
        if so changes colors and frequency of LEDs accordingly and publishes
        the new current pattern.

        Args:
            pattern_name (string): Name of the wanted pattern

        """
        if pattern_name:
            # No need to change if we already have the right pattern
            if self.current_pattern_name == pattern_name:
                return
            else:
                self.current_pattern_name = pattern_name

            # Extract the color from the protocol config file
            color = self.protocol['signals'][pattern_name]['color']
            self.pattern = [color]*5
            try:
                # Extract the frequency from the config file, if not static
                self.cycle = self.protocol['signals'][pattern_name]['frequency']
            except KeyError:
                # If static, no timer
                self.cycle = []

            # Change frequency (frequency does not change)
            self.changeFrequency()

            # Change LEDs
            if not self.onOff:
                self.cycleTimer([])

            # Loginfo
            rospy.loginfo('[%s] Pattern changed to (%r), cycle: %s '
                          % (self.node_name, pattern_name, self.cycle))

            # Publish current pattern
            self.pub_state.publish(self.current_pattern_name)

    def changeFrequency(self):
        """Changes current frequency of LEDs

        Stops the current cycle_timer, and starts a new one with the right
        frequency.
        """
        try:
            # self.cycle = msg.data
            self.cycle_timer.shutdown()
            # below, convert to hz
            d = 1.0/(2.0*self.cycle)
            self.cycle_timer = rospy.Timer(rospy.Duration.from_sec(d), self.cycleTimer)
        except ValueError as e:
            self.cycle = None
            self.current_pattern_name = None
        self.pub_state.publish(float(self.cycle))


if __name__ == '__main__':
    rospy.init_node('led_emitter', anonymous=False)
    led_emitter_node = LEDEmitterNode()
    rospy.spin()
